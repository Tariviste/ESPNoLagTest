-- boy do i hope this works

-- Services

local Players = game:GetService("Players")
local RS = game:GetService("RunService")

-- Variables

local Plr = Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Camera = workspace.CurrentCamera

local ESP = {
	Containers = {},
	Settings = {
		DisplayNames = true,
		Distance = true,
		Health = true,
		Tracer = true,
		TracerThickness = 1,
		Outline = true,
		TracerFrom = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 25),
		OutlineOpacity = 0.75,
		OutlineOnTop = true,
		Rainbow = false,
		TextSize = 16,
	},
}

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	Camera = workspace.CurrentCamera
	ESP.Settings.TracerFrom = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 25)
end)

-- Misc Functions

local function onCharacterAdded(char)
	Char, Root = char, char:WaitForChild("HumanoidRootPart")
end

local function getPlayerFromRoot(root)
	for _, v in next, Players:GetPlayers() do
		if v.Character and root:IsDescendantOf(v.Character) then
			return v
		end
	end
end

local function getWTVP(vec3)
	local screenPos, onScreen = Camera:WorldToViewportPoint(vec3)

	if not screenPos 
		or screenPos ~= screenPos 
		or math.abs(screenPos.Z) == math.huge then
		return nil, false
	end

	if screenPos.X == 0 and screenPos.Y == 0 then
		return nil, false
	end

	return Vector2.new(screenPos.X, screenPos.Y), onScreen
end

local function isAlive(root)
	if not root:IsDescendantOf(workspace) then
		return false
	elseif root.Parent:FindFirstChild("Humanoid") and root.Parent.Humanoid.Health <= 0 then
		return false
	end

	local pos = root.Position
	if not pos or pos ~= pos then
		ESP:Remove(root)
		return false
	end

	return true
end

-- Functions

function ESP:Add(root, options)
	if self.Containers[root] then return end

	if not root.Position or root.Position ~= root.Position then
		ESP:Remove(root)
		return
	end

	local settings = table.clone(self.Settings)
	if options then
		for k,v in pairs(options) do
			settings[k] = v
		end
	end

	local player = getPlayerFromRoot(root)

	local container = {
		Active = true,
		Root = root,
		Player = player,
		Name = options.Name or (player and player[settings.DisplayNames and "DisplayName" or "Name"]) or root.Name,
		Color = options.Color or (player and player.Team and player.TeamColor.Color) or Color3.new(1,1,1),
		OutlineFocus = options.OutlineFocus or (player and player.Character) or (root.Parent and root.Parent.ClassName == "Model" and root.Parent) or root,
		Connections = {},
		Draw = {},
		Settings = settings,
	}

	if not settings.disableName then
		local nameLabel = Drawing.new("Text")
		nameLabel.Center = true
		nameLabel.Color = container.Color
		nameLabel.Outline = true
		nameLabel.Size = settings.TextSize
		nameLabel.Text = container.Name
		container.Draw[#container.Draw+1] = {Type="Text", Name="Name", Obj=nameLabel}
	end

	if not settings.disableDistance or not settings.disableHealth then
		local statsLabel = Drawing.new("Text")
		statsLabel.Center = true
		statsLabel.Outline = true
		statsLabel.Color = Color3.new(1,1,1)
		statsLabel.Size = settings.TextSize
		container.Draw[#container.Draw+1] = {Type="Text", Name="Stats", Obj=statsLabel}
	end

	if not settings.disableTracer then
		local tracer = Drawing.new("Line")
		tracer.Color = container.Color
		tracer.From = settings.TracerFrom
		tracer.Thickness = settings.TracerThickness
		container.Draw[#container.Draw+1] = {Type="Line", Name="Tracer", Obj=tracer}
	end

	if not settings.disableOutline then
		local outline = Instance.new("Highlight")
		if not root.Parent or not root.Parent.Parent then
			return
		end

		if root.Parent ~= root.Parent or root.Parent.Parent ~= root.Parent.Parent then
			ESP:Remove(root)
			return
		end

		outline.Enabled = false
		outline.FillColor = container.Color
		outline.FillTransparency = 0.75
		outline.OutlineColor = container.Color
		outline.OutlineTransparency = 0
		outline.Parent = container.OutlineFocus
		container.Draw[#container.Draw+1] = {Type="Outline", Name="Outline", Obj=outline}
	end

	if options.DeletedFunction then
		container.RemovedFunctionInLoop = options.DeletedFunction
	end

	if player then
		container.Connections.changeTeam = player:GetPropertyChangedSignal("Team"):Connect(function()
			self:Remove(container.Root)
		end)
	end

	self.Containers[root] = container
	return container
end

function ChangeProperty(Obj, Prop, Val)
	if Obj[Prop] == Val then return end
	Obj[Prop] = Val
end

function ESP:Remove(root)
	local container = self.Containers[root]

	if container then
		if container.RemovedFunctionInLoop then
			container.RemovedFunctionInLoop()
		end
		container.Active = false

		for _, v in next, container.Connections do
			v:Disconnect(); v = nil
		end

		for _, v in next, container.Draw do
			if v.Type ~= "Outline" then
				ChangeProperty(v.Obj, "Visible", false)
			else
				v.Obj:Destroy()
			end
			v = nil
		end

		self.Containers[root] = nil
	end
end

function ESP:UpdateContainer(container, root)	
	if not root.Position or root.Position ~= root.Position then
		ESP:Remove(root)
		return
	end

	local ScreenPosition, OnScreen = getWTVP(root.Position)

	if not ScreenPosition then
		ESP:Remove(root)
		return
	end
	if not OnScreen then
		for _, v in next, container.Draw do
			if v.Type ~= "Outline" then
				ChangeProperty(v.Obj, "Visible", false)
			end
		end
		return
	end

	local TextCount = 0
	for _, v in next, container.Draw do
		if v.Type == "Text" and v.Obj.Text ~= "" then
			TextCount += 1
		end
	end

	local OffsetVector = Vector2.new(0, math.max(TextCount * self.Settings.TextSize / 2, self.Settings.TextSize))
	local TextSizeOffset = Vector2.new(0, self.Settings.TextSize)
	local HPText, DistText = "", ""

	local humanoid = root.Parent:FindFirstChild("Humanoid")
	if self.Settings.Distance and not container.Settings.disableDistance then
		DistText = "[ " .. math.floor((root.Position - Root.Position).Magnitude) .. " ]"
	end
	if self.Settings.Health and humanoid and not container.Settings.disableHealth then
		local HP = math.floor(100 / humanoid.MaxHealth * humanoid.Health * 10) / 10
		HPText = " [ " .. HP .. "% ]"
	end

	local StatsText = DistText .. HPText
	local Color = (self.Settings.Rainbow and not container.Settings.disableRainbow) and Color3.fromHSV(tick() % 5 / 5, 1, 1) or container.Color

	for i, v in next, container.Draw do
		local obj = v.Obj

		if v.Type ~= "Outline" then
			if v.Type == "Text" then
				ChangeProperty(obj, "Size", self.Settings.TextSize)
				ChangeProperty(obj, "Position", ScreenPosition - TextSizeOffset * (TextCount - i))

				if v.Name == "Name" then
					ChangeProperty(obj, "Text", container.Name)
				elseif v.Name == "Stats" then
					ChangeProperty(obj, "Text", StatsText)
				end

			elseif v.Type == "Line" and self.Settings.Tracer and not container.Settings.disableTracer then
				ChangeProperty(obj, "From", self.Settings.TracerFrom)
				ChangeProperty(obj, "To", ScreenPosition + OffsetVector)
				ChangeProperty(obj, "Thickness", self.Settings.TracerThickness)
			end

			ChangeProperty(obj, "Color", Color)
			ChangeProperty(obj, "Visible", v.Type ~= "Line" or self.Settings.Tracer)

		else
			if not container.Settings.disableOutline then
				local highlight = obj
				local depth = Enum.HighlightDepthMode[self.Settings.OutlineOnTop and "AlwaysOnTop" or "Occluded"]
				ChangeProperty(highlight, "FillColor", Color)
				ChangeProperty(highlight, "OutlineColor", Color)
				ChangeProperty(highlight, "FillTransparency", self.Settings.OutlineOpacity)
				ChangeProperty(highlight, "DepthMode", depth)
				ChangeProperty(highlight, "Enabled", self.Settings.Outline)
				ChangeProperty(highlight, "Parent", container.OutlineFocus)
			end
		end
	end
end

-- Scripts

onCharacterAdded(Char)
Plr.CharacterAdded:Connect(onCharacterAdded)

RS.Stepped:Connect(function()
	if not Char or not Root or not Camera then
		return
	end

	for root, container in next, ESP.Containers do
		if not root.Position or root.Position ~= root.Position then
			ESP:Remove(root)
			continue
		end

		if not isAlive(root) or not container.Active then
			ESP:Remove(root)
			continue
		end

		ESP:UpdateContainer(container, root)
	end
end)

return ESP
